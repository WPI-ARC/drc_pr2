/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 61 generated on 2013-04-04 19:34:04.838592
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==61);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IKFAST_STRINGIZE2(s) #s
#define IKFAST_STRINGIZE(s) IKFAST_STRINGIZE2(s)

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)0.000001)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[0]);
x3=IKsin(j[1]);
x4=IKsin(j[2]);
x5=IKcos(j[2]);
x6=((IkReal(0.140000000000000))*(x2));
x7=((IkReal(0.140000000000000))*(x0));
x8=((IkReal(0.125000000000000))*(x2));
x9=((IkReal(0.125000000000000))*(x0));
x10=((((IkReal(-1.00000000000000))*(x3)*(x8)))+(((x1)*(x9))));
x11=((((x1)*(x8)))+(((x3)*(x9))));
eetrans[0]=((x7)+(((IkReal(-1.00000000000000))*(x3)*(x6)))+(((IkReal(-1.00000000000000))*(x11)*(x4)))+(((x10)*(x5)))+(((x1)*(x7))));
eetrans[1]=((x6)+(((x10)*(x4)))+(((x3)*(x7)))+(((x11)*(x5)))+(((x1)*(x6))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 3; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x22000008; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j1,cj1,sj1,htj1,j2,cj2,sj2,htj2,new_px,px,npx,new_py,py,npy;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2;

bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]);
px = eetrans[0]; py = eetrans[1];

new_px=px;
new_py=py;
px = new_px; py = new_py;
{
IkReal dummyeval[1];
dummyeval[0]=(((px)*(px))+((py)*(py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=(((px)*(px))+((py)*(py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((IkReal(1.25440000000000))+(((IkReal(2.24000000000000))*(cj2)))+((cj2)*(cj2))+((sj2)*(sj2)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x12=((IkReal(0.0350000000000000))*(cj2));
IkReal x13=((IkReal(0.0392000000000000))+(x12));
if( IKabs(x13) < IKFAST_ATAN2_MAGTHRESH && IKabs(((IkReal(-0.0350000000000000))*(sj2))) < IKFAST_ATAN2_MAGTHRESH )
    continue;
IkReal x14=((IkReal(1.00000000000000))*(IKatan2(x13, ((IkReal(-0.0350000000000000))*(sj2)))));
if( (((((IkReal(0.00122500000000000))*((sj2)*(sj2))))+((x13)*(x13)))) < (IkReal)-0.00001 )
    continue;
if( (((((IKabs(IKabs(IKsqrt(((((IkReal(0.00122500000000000))*((sj2)*(sj2))))+((x13)*(x13)))))) != 0)?((IkReal)1/(IKabs(IKsqrt(((((IkReal(0.00122500000000000))*((sj2)*(sj2))))+((x13)*(x13))))))):(IkReal)1.0e30))*(((IkReal(0.0548250000000000))+(x12)+(((IkReal(-1.00000000000000))*((py)*(py))))+(((IkReal(-1.00000000000000))*((px)*(px)))))))) < -1-IKFAST_SINCOS_THRESH || (((((IKabs(IKabs(IKsqrt(((((IkReal(0.00122500000000000))*((sj2)*(sj2))))+((x13)*(x13)))))) != 0)?((IkReal)1/(IKabs(IKsqrt(((((IkReal(0.00122500000000000))*((sj2)*(sj2))))+((x13)*(x13))))))):(IkReal)1.0e30))*(((IkReal(0.0548250000000000))+(x12)+(((IkReal(-1.00000000000000))*((py)*(py))))+(((IkReal(-1.00000000000000))*((px)*(px)))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x15=IKasin(((((IKabs(IKabs(IKsqrt(((((IkReal(0.00122500000000000))*((sj2)*(sj2))))+((x13)*(x13)))))) != 0)?((IkReal)1/(IKabs(IKsqrt(((((IkReal(0.00122500000000000))*((sj2)*(sj2))))+((x13)*(x13))))))):(IkReal)1.0e30))*(((IkReal(0.0548250000000000))+(x12)+(((IkReal(-1.00000000000000))*((py)*(py))))+(((IkReal(-1.00000000000000))*((px)*(px))))))));
j1array[0]=((((IkReal(-1.00000000000000))*(x14)))+(((IkReal(-1.00000000000000))*(x15))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((IkReal(3.14159265358979))+(x15)+(((IkReal(-1.00000000000000))*(x14))));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal dummyeval[1];
IkReal gconst0;
gconst0=IKsign((((px)*(px))+((py)*(py))));
dummyeval[0]=(((px)*(px))+((py)*(py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst1;
gconst1=IKsign(((((IkReal(-7.00000000000000))*((px)*(px))))+(((IkReal(-7.00000000000000))*((py)*(py))))));
dummyeval[0]=((((IkReal(-1.00000000000000))*((py)*(py))))+(((IkReal(-1.00000000000000))*((px)*(px)))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x16=((IkReal(0.875000000000000))*(py));
IkReal x17=((cj2)*(sj1));
IkReal x18=((cj1)*(sj2));
IkReal x19=((IkReal(0.875000000000000))*(px));
IkReal x20=((IkReal(0.980000000000000))*(sj1));
if( IKabs(((gconst1)*(((((x17)*(x19)))+(((x18)*(x19)))+(((IkReal(-25.0000000000000))*(py)*((px)*(px))))+(((IkReal(0.390625000000000))*(py)))+(((px)*(x20)))+(((IkReal(-25.0000000000000))*((py)*(py)*(py))))+(((cj2)*(x16))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((gconst1)*(((((IkReal(0.390625000000000))*(px)))+(((IkReal(-1.00000000000000))*(x16)*(x17)))+(((IkReal(-25.0000000000000))*(px)*((py)*(py))))+(((IkReal(-1.00000000000000))*(x16)*(x18)))+(((IkReal(-25.0000000000000))*((px)*(px)*(px))))+(((IkReal(-1.00000000000000))*(py)*(x20)))+(((cj2)*(x19))))))) < IKFAST_ATAN2_MAGTHRESH )
    continue;
j0array[0]=IKatan2(((gconst1)*(((((x17)*(x19)))+(((x18)*(x19)))+(((IkReal(-25.0000000000000))*(py)*((px)*(px))))+(((IkReal(0.390625000000000))*(py)))+(((px)*(x20)))+(((IkReal(-25.0000000000000))*((py)*(py)*(py))))+(((cj2)*(x16)))))), ((gconst1)*(((((IkReal(0.390625000000000))*(px)))+(((IkReal(-1.00000000000000))*(x16)*(x17)))+(((IkReal(-25.0000000000000))*(px)*((py)*(py))))+(((IkReal(-1.00000000000000))*(x16)*(x18)))+(((IkReal(-25.0000000000000))*((px)*(px)*(px))))+(((IkReal(-1.00000000000000))*(py)*(x20)))+(((cj2)*(x19)))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x21=IKsin(j0);
IkReal x22=IKcos(j0);
IkReal x23=((IkReal(1.00000000000000))*(px));
IkReal x24=((IkReal(0.125000000000000))*(cj1));
IkReal x25=((IkReal(0.125000000000000))*(sj2));
IkReal x26=((IkReal(0.140000000000000))*(cj1));
IkReal x27=((IkReal(1.00000000000000))*(py));
IkReal x28=((IkReal(0.125000000000000))*(cj2));
IkReal x29=((IkReal(0.140000000000000))*(x21));
IkReal x30=((sj1)*(x22));
IkReal x31=((py)*(x21));
IkReal x32=((sj1)*(x21));
evalcond[0]=((IkReal(0.0156250000000000))+(((IkReal(0.0350000000000000))*(cj2)))+(((IkReal(-1.00000000000000))*(px)*(x23)))+(((IkReal(0.280000000000000))*(px)*(x22)))+(((IkReal(0.280000000000000))*(x31)))+(((IkReal(-1.00000000000000))*(py)*(x27))));
evalcond[1]=((((sj2)*(x24)))+(((IkReal(-1.00000000000000))*(x22)*(x27)))+(((sj1)*(x28)))+(((IkReal(0.140000000000000))*(sj1)))+(((px)*(x21))));
evalcond[2]=((IkReal(0.140000000000000))+(((IkReal(-1.00000000000000))*(x21)*(x27)))+(((IkReal(-1.00000000000000))*(sj1)*(x25)))+(x26)+(((cj2)*(x24)))+(((IkReal(-1.00000000000000))*(x22)*(x23))));
evalcond[3]=((((IkReal(-1.00000000000000))*(sj1)*(x29)))+(((IkReal(-1.00000000000000))*(x25)*(x30)))+(((IkReal(-1.00000000000000))*(sj2)*(x21)*(x24)))+(((cj2)*(x22)*(x24)))+(((IkReal(-1.00000000000000))*(x28)*(x32)))+(((x22)*(x26)))+(((IkReal(0.140000000000000))*(x22)))+(((IkReal(-1.00000000000000))*(x23))));
evalcond[4]=((((x21)*(x26)))+(((sj2)*(x22)*(x24)))+(x29)+(((IkReal(0.140000000000000))*(x30)))+(((IkReal(-1.00000000000000))*(x27)))+(((x28)*(x30)))+(((IkReal(-1.00000000000000))*(x25)*(x32)))+(((cj2)*(x21)*(x24))));
if( IKabs(evalcond[0]) > 0.000001  || IKabs(evalcond[1]) > 0.000001  || IKabs(evalcond[2]) > 0.000001  || IKabs(evalcond[3]) > 0.000001  || IKabs(evalcond[4]) > 0.000001  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x33=((IkReal(0.125000000000000))*(sj2));
IkReal x34=((py)*(sj1));
IkReal x35=((cj1)*(px));
IkReal x36=((cj1)*(py));
IkReal x37=((IkReal(0.140000000000000))*(px));
IkReal x38=((IkReal(0.125000000000000))*(cj2));
IkReal x39=((px)*(sj1));
if( IKabs(((gconst0)*(((((IkReal(-1.00000000000000))*(x38)*(x39)))+(((IkReal(-1.00000000000000))*(x33)*(x35)))+(((IkReal(-1.00000000000000))*(x33)*(x34)))+(((IkReal(0.140000000000000))*(x36)))+(((IkReal(0.140000000000000))*(py)))+(((IkReal(-1.00000000000000))*(sj1)*(x37)))+(((x36)*(x38))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((gconst0)*(((((x34)*(x38)))+(x37)+(((IkReal(0.140000000000000))*(x34)))+(((IkReal(0.140000000000000))*(x35)))+(((IkReal(-1.00000000000000))*(x33)*(x39)))+(((x33)*(x36)))+(((x35)*(x38))))))) < IKFAST_ATAN2_MAGTHRESH )
    continue;
j0array[0]=IKatan2(((gconst0)*(((((IkReal(-1.00000000000000))*(x38)*(x39)))+(((IkReal(-1.00000000000000))*(x33)*(x35)))+(((IkReal(-1.00000000000000))*(x33)*(x34)))+(((IkReal(0.140000000000000))*(x36)))+(((IkReal(0.140000000000000))*(py)))+(((IkReal(-1.00000000000000))*(sj1)*(x37)))+(((x36)*(x38)))))), ((gconst0)*(((((x34)*(x38)))+(x37)+(((IkReal(0.140000000000000))*(x34)))+(((IkReal(0.140000000000000))*(x35)))+(((IkReal(-1.00000000000000))*(x33)*(x39)))+(((x33)*(x36)))+(((x35)*(x38)))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x40=IKsin(j0);
IkReal x41=IKcos(j0);
IkReal x42=((IkReal(1.00000000000000))*(px));
IkReal x43=((IkReal(0.125000000000000))*(cj1));
IkReal x44=((IkReal(0.125000000000000))*(sj2));
IkReal x45=((IkReal(0.140000000000000))*(cj1));
IkReal x46=((IkReal(1.00000000000000))*(py));
IkReal x47=((IkReal(0.125000000000000))*(cj2));
IkReal x48=((IkReal(0.140000000000000))*(x40));
IkReal x49=((sj1)*(x41));
IkReal x50=((py)*(x40));
IkReal x51=((sj1)*(x40));
evalcond[0]=((IkReal(0.0156250000000000))+(((IkReal(-1.00000000000000))*(px)*(x42)))+(((IkReal(0.0350000000000000))*(cj2)))+(((IkReal(0.280000000000000))*(x50)))+(((IkReal(0.280000000000000))*(px)*(x41)))+(((IkReal(-1.00000000000000))*(py)*(x46))));
evalcond[1]=((((sj1)*(x47)))+(((sj2)*(x43)))+(((IkReal(-1.00000000000000))*(x41)*(x46)))+(((IkReal(0.140000000000000))*(sj1)))+(((px)*(x40))));
evalcond[2]=((IkReal(0.140000000000000))+(((IkReal(-1.00000000000000))*(sj1)*(x44)))+(((IkReal(-1.00000000000000))*(x41)*(x42)))+(x45)+(((cj2)*(x43)))+(((IkReal(-1.00000000000000))*(x40)*(x46))));
evalcond[3]=((((IkReal(0.140000000000000))*(x41)))+(((IkReal(-1.00000000000000))*(x47)*(x51)))+(((IkReal(-1.00000000000000))*(x44)*(x49)))+(((IkReal(-1.00000000000000))*(x42)))+(((IkReal(-1.00000000000000))*(sj2)*(x40)*(x43)))+(((IkReal(-1.00000000000000))*(sj1)*(x48)))+(((cj2)*(x41)*(x43)))+(((x41)*(x45))));
evalcond[4]=((((cj2)*(x40)*(x43)))+(((x40)*(x45)))+(((IkReal(-1.00000000000000))*(x46)))+(x48)+(((IkReal(0.140000000000000))*(x49)))+(((IkReal(-1.00000000000000))*(x44)*(x51)))+(((x47)*(x49)))+(((sj2)*(x41)*(x43))));
if( IKabs(evalcond[0]) > 0.000001  || IKabs(evalcond[1]) > 0.000001  || IKabs(evalcond[2]) > 0.000001  || IKabs(evalcond[3]) > 0.000001  || IKabs(evalcond[4]) > 0.000001  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x52=(px)*(px);
IkReal x53=(py)*(py);
if( IKabs(((IkReal(0.280000000000000))*(px))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((IkReal(0.280000000000000))*(py))) < IKFAST_ATAN2_MAGTHRESH )
    continue;
IkReal x54=((IkReal(1.00000000000000))*(IKatan2(((IkReal(0.280000000000000))*(px)), ((IkReal(0.280000000000000))*(py)))));
if( (((((IkReal(0.0784000000000000))*(x52)))+(((IkReal(0.0784000000000000))*(x53))))) < (IkReal)-0.00001 )
    continue;
if( (((((IKabs(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x52)))+(((IkReal(0.0784000000000000))*(x53))))))) != 0)?((IkReal)1/(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x52)))+(((IkReal(0.0784000000000000))*(x53)))))))):(IkReal)1.0e30))*(((IkReal(0.0156250000000000))+(((IkReal(0.0350000000000000))*(cj2)))+(((IkReal(-1.00000000000000))*(x52)))+(((IkReal(-1.00000000000000))*(x53))))))) < -1-IKFAST_SINCOS_THRESH || (((((IKabs(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x52)))+(((IkReal(0.0784000000000000))*(x53))))))) != 0)?((IkReal)1/(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x52)))+(((IkReal(0.0784000000000000))*(x53)))))))):(IkReal)1.0e30))*(((IkReal(0.0156250000000000))+(((IkReal(0.0350000000000000))*(cj2)))+(((IkReal(-1.00000000000000))*(x52)))+(((IkReal(-1.00000000000000))*(x53))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x55=IKasin(((((IKabs(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x52)))+(((IkReal(0.0784000000000000))*(x53))))))) != 0)?((IkReal)1/(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x52)))+(((IkReal(0.0784000000000000))*(x53)))))))):(IkReal)1.0e30))*(((IkReal(0.0156250000000000))+(((IkReal(0.0350000000000000))*(cj2)))+(((IkReal(-1.00000000000000))*(x52)))+(((IkReal(-1.00000000000000))*(x53)))))));
j0array[0]=((((IkReal(-1.00000000000000))*(x55)))+(((IkReal(-1.00000000000000))*(x54))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((IkReal(3.14159265358979))+(x55)+(((IkReal(-1.00000000000000))*(x54))));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal dummyeval[1];
IkReal gconst2;
gconst2=IKsign(((IkReal(1.25440000000000))+(((IkReal(2.24000000000000))*(cj2)))+((cj2)*(cj2))+((sj2)*(sj2))));
dummyeval[0]=((IkReal(1.25440000000000))+(((IkReal(2.24000000000000))*(cj2)))+((cj2)*(cj2))+((sj2)*(sj2)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst3;
gconst3=IKsign(((IkReal(8.78080000000000))+(((IkReal(15.6800000000000))*(cj2)))+(((IkReal(7.00000000000000))*((sj2)*(sj2))))+(((IkReal(7.00000000000000))*((cj2)*(cj2))))));
dummyeval[0]=((IkReal(1.25440000000000))+(((IkReal(2.24000000000000))*(cj2)))+((cj2)*(cj2))+((sj2)*(sj2)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x56=(px)*(px);
IkReal x57=(py)*(py);
IkReal x58=((IkReal(200.000000000000))*(sj2));
IkReal x59=((IkReal(56.0000000000000))*(sj2));
IkReal x60=((px)*(sj0));
IkReal x61=((cj0)*(py));
IkReal x62=((IkReal(56.0000000000000))*(cj2));
IkReal x63=((IkReal(200.000000000000))*(cj2));
if( IKabs(((gconst3)*(((((IkReal(62.7200000000000))*(x61)))+(((x61)*(x62)))+(((IkReal(-1.00000000000000))*(x56)*(x58)))+(((IkReal(-1.00000000000000))*(x57)*(x58)))+(((IkReal(7.00000000000000))*(cj2)*(sj2)))+(((IkReal(10.9650000000000))*(sj2)))+(((IkReal(-1.00000000000000))*(x60)*(x62)))+(((IkReal(-62.7200000000000))*(x60))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((gconst3)*(((IkReal(-12.2808000000000))+(((x59)*(x61)))+(((IkReal(-18.8050000000000))*(cj2)))+(((x56)*(x63)))+(((IkReal(-1.00000000000000))*(x59)*(x60)))+(((IkReal(224.000000000000))*(x57)))+(((IkReal(-7.00000000000000))*((cj2)*(cj2))))+(((IkReal(224.000000000000))*(x56)))+(((x57)*(x63))))))) < IKFAST_ATAN2_MAGTHRESH )
    continue;
j1array[0]=IKatan2(((gconst3)*(((((IkReal(62.7200000000000))*(x61)))+(((x61)*(x62)))+(((IkReal(-1.00000000000000))*(x56)*(x58)))+(((IkReal(-1.00000000000000))*(x57)*(x58)))+(((IkReal(7.00000000000000))*(cj2)*(sj2)))+(((IkReal(10.9650000000000))*(sj2)))+(((IkReal(-1.00000000000000))*(x60)*(x62)))+(((IkReal(-62.7200000000000))*(x60)))))), ((gconst3)*(((IkReal(-12.2808000000000))+(((x59)*(x61)))+(((IkReal(-18.8050000000000))*(cj2)))+(((x56)*(x63)))+(((IkReal(-1.00000000000000))*(x59)*(x60)))+(((IkReal(224.000000000000))*(x57)))+(((IkReal(-7.00000000000000))*((cj2)*(cj2))))+(((IkReal(224.000000000000))*(x56)))+(((x57)*(x63)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x64=IKsin(j1);
IkReal x65=IKcos(j1);
IkReal x66=((IkReal(1.00000000000000))*(py));
IkReal x67=((IkReal(0.125000000000000))*(sj2));
IkReal x68=((IkReal(0.140000000000000))*(sj0));
IkReal x69=((IkReal(0.125000000000000))*(cj2));
IkReal x70=((IkReal(0.0350000000000000))*(cj2));
IkReal x71=((IkReal(1.00000000000000))*(px));
IkReal x72=((sj0)*(x65));
IkReal x73=((cj0)*(x64));
IkReal x74=((IkReal(0.140000000000000))*(x65));
IkReal x75=((cj0)*(x65));
IkReal x76=((x64)*(x69));
evalcond[0]=((((x65)*(x67)))+(((IkReal(-1.00000000000000))*(cj0)*(x66)))+(x76)+(((px)*(sj0)))+(((IkReal(0.140000000000000))*(x64))));
evalcond[1]=((IkReal(0.140000000000000))+(((x65)*(x69)))+(((IkReal(-1.00000000000000))*(x64)*(x67)))+(((IkReal(-1.00000000000000))*(cj0)*(x71)))+(((IkReal(-1.00000000000000))*(sj0)*(x66)))+(x74));
evalcond[2]=((IkReal(0.0548250000000000))+(((x65)*(x70)))+(((IkReal(-1.00000000000000))*(py)*(x66)))+(((IkReal(0.0392000000000000))*(x65)))+(x70)+(((IkReal(-1.00000000000000))*(px)*(x71)))+(((IkReal(-0.0350000000000000))*(sj2)*(x64))));
evalcond[3]=((((IkReal(-1.00000000000000))*(x67)*(x73)))+(((IkReal(-1.00000000000000))*(x64)*(x68)))+(((IkReal(-1.00000000000000))*(sj0)*(x76)))+(((x69)*(x75)))+(((IkReal(-1.00000000000000))*(x67)*(x72)))+(((cj0)*(x74)))+(((IkReal(-1.00000000000000))*(x71)))+(((IkReal(0.140000000000000))*(cj0))));
evalcond[4]=((x68)+(((x67)*(x75)))+(((x65)*(x68)))+(((x69)*(x72)))+(((IkReal(-1.00000000000000))*(sj0)*(x64)*(x67)))+(((IkReal(-1.00000000000000))*(x66)))+(((IkReal(0.140000000000000))*(x73)))+(((x69)*(x73))));
if( IKabs(evalcond[0]) > 0.000001  || IKabs(evalcond[1]) > 0.000001  || IKabs(evalcond[2]) > 0.000001  || IKabs(evalcond[3]) > 0.000001  || IKabs(evalcond[4]) > 0.000001  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x77=((IkReal(8.96000000000000))*(py));
IkReal x78=((cj0)*(px));
IkReal x79=((IkReal(8.00000000000000))*(cj2));
IkReal x80=((cj0)*(py));
IkReal x81=((py)*(sj0));
IkReal x82=((IkReal(8.00000000000000))*(sj2));
IkReal x83=((IkReal(8.00000000000000))*(px)*(sj0));
if( IKabs(((gconst2)*(((((IkReal(-1.00000000000000))*(px)*(sj0)*(x79)))+(((x79)*(x80)))+(((IkReal(-8.96000000000000))*(px)*(sj0)))+(((IkReal(-1.00000000000000))*(x78)*(x82)))+(((cj0)*(x77)))+(((IkReal(-1.00000000000000))*(x81)*(x82)))+(((IkReal(1.12000000000000))*(sj2))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((gconst2)*(((IkReal(-1.25440000000000))+(((x80)*(x82)))+(((x78)*(x79)))+(((sj0)*(x77)))+(((x79)*(x81)))+(((IkReal(-1.12000000000000))*(cj2)))+(((IkReal(8.96000000000000))*(x78)))+(((IkReal(-1.00000000000000))*(px)*(sj0)*(x82))))))) < IKFAST_ATAN2_MAGTHRESH )
    continue;
j1array[0]=IKatan2(((gconst2)*(((((IkReal(-1.00000000000000))*(px)*(sj0)*(x79)))+(((x79)*(x80)))+(((IkReal(-8.96000000000000))*(px)*(sj0)))+(((IkReal(-1.00000000000000))*(x78)*(x82)))+(((cj0)*(x77)))+(((IkReal(-1.00000000000000))*(x81)*(x82)))+(((IkReal(1.12000000000000))*(sj2)))))), ((gconst2)*(((IkReal(-1.25440000000000))+(((x80)*(x82)))+(((x78)*(x79)))+(((sj0)*(x77)))+(((x79)*(x81)))+(((IkReal(-1.12000000000000))*(cj2)))+(((IkReal(8.96000000000000))*(x78)))+(((IkReal(-1.00000000000000))*(px)*(sj0)*(x82)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x84=IKsin(j1);
IkReal x85=IKcos(j1);
IkReal x86=((IkReal(1.00000000000000))*(py));
IkReal x87=((IkReal(0.125000000000000))*(sj2));
IkReal x88=((IkReal(0.140000000000000))*(sj0));
IkReal x89=((IkReal(0.125000000000000))*(cj2));
IkReal x90=((IkReal(0.0350000000000000))*(cj2));
IkReal x91=((IkReal(1.00000000000000))*(px));
IkReal x92=((sj0)*(x85));
IkReal x93=((cj0)*(x84));
IkReal x94=((IkReal(0.140000000000000))*(x85));
IkReal x95=((cj0)*(x85));
IkReal x96=((x84)*(x89));
evalcond[0]=((((IkReal(0.140000000000000))*(x84)))+(((x85)*(x87)))+(((px)*(sj0)))+(((IkReal(-1.00000000000000))*(cj0)*(x86)))+(x96));
evalcond[1]=((IkReal(0.140000000000000))+(((IkReal(-1.00000000000000))*(cj0)*(x91)))+(((x85)*(x89)))+(((IkReal(-1.00000000000000))*(sj0)*(x86)))+(((IkReal(-1.00000000000000))*(x84)*(x87)))+(x94));
evalcond[2]=((IkReal(0.0548250000000000))+(((x85)*(x90)))+(((IkReal(-0.0350000000000000))*(sj2)*(x84)))+(((IkReal(-1.00000000000000))*(px)*(x91)))+(((IkReal(0.0392000000000000))*(x85)))+(((IkReal(-1.00000000000000))*(py)*(x86)))+(x90));
evalcond[3]=((((IkReal(-1.00000000000000))*(sj0)*(x96)))+(((IkReal(-1.00000000000000))*(x87)*(x92)))+(((x89)*(x95)))+(((IkReal(-1.00000000000000))*(x87)*(x93)))+(((IkReal(-1.00000000000000))*(x84)*(x88)))+(((cj0)*(x94)))+(((IkReal(-1.00000000000000))*(x91)))+(((IkReal(0.140000000000000))*(cj0))));
evalcond[4]=((((x89)*(x92)))+(((IkReal(-1.00000000000000))*(x86)))+(((IkReal(0.140000000000000))*(x93)))+(((x87)*(x95)))+(((x85)*(x88)))+(((x89)*(x93)))+(((IkReal(-1.00000000000000))*(sj0)*(x84)*(x87)))+(x88));
if( IKabs(evalcond[0]) > 0.000001  || IKabs(evalcond[1]) > 0.000001  || IKabs(evalcond[2]) > 0.000001  || IKabs(evalcond[3]) > 0.000001  || IKabs(evalcond[4]) > 0.000001  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x97=(px)*(px);
IkReal x98=(py)*(py);
if( IKabs(((IkReal(0.280000000000000))*(px))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((IkReal(0.280000000000000))*(py))) < IKFAST_ATAN2_MAGTHRESH )
    continue;
IkReal x99=((IkReal(1.00000000000000))*(IKatan2(((IkReal(0.280000000000000))*(px)), ((IkReal(0.280000000000000))*(py)))));
if( (((((IkReal(0.0784000000000000))*(x97)))+(((IkReal(0.0784000000000000))*(x98))))) < (IkReal)-0.00001 )
    continue;
if( (((((IKabs(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x97)))+(((IkReal(0.0784000000000000))*(x98))))))) != 0)?((IkReal)1/(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x97)))+(((IkReal(0.0784000000000000))*(x98)))))))):(IkReal)1.0e30))*(((IkReal(0.0156250000000000))+(((IkReal(-1.00000000000000))*(x97)))+(((IkReal(-1.00000000000000))*(x98)))+(((IkReal(0.0350000000000000))*(cj2))))))) < -1-IKFAST_SINCOS_THRESH || (((((IKabs(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x97)))+(((IkReal(0.0784000000000000))*(x98))))))) != 0)?((IkReal)1/(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x97)))+(((IkReal(0.0784000000000000))*(x98)))))))):(IkReal)1.0e30))*(((IkReal(0.0156250000000000))+(((IkReal(-1.00000000000000))*(x97)))+(((IkReal(-1.00000000000000))*(x98)))+(((IkReal(0.0350000000000000))*(cj2))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x100=IKasin(((((IKabs(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x97)))+(((IkReal(0.0784000000000000))*(x98))))))) != 0)?((IkReal)1/(IKabs(IKsqrt(((((IkReal(0.0784000000000000))*(x97)))+(((IkReal(0.0784000000000000))*(x98)))))))):(IkReal)1.0e30))*(((IkReal(0.0156250000000000))+(((IkReal(-1.00000000000000))*(x97)))+(((IkReal(-1.00000000000000))*(x98)))+(((IkReal(0.0350000000000000))*(cj2)))))));
j0array[0]=((((IkReal(-1.00000000000000))*(x100)))+(((IkReal(-1.00000000000000))*(x99))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((IkReal(3.14159265358979))+(((IkReal(-1.00000000000000))*(x99)))+(x100));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal dummyeval[1];
IkReal gconst2;
gconst2=IKsign(((IkReal(1.25440000000000))+(((IkReal(2.24000000000000))*(cj2)))+((cj2)*(cj2))+((sj2)*(sj2))));
dummyeval[0]=((IkReal(1.25440000000000))+(((IkReal(2.24000000000000))*(cj2)))+((cj2)*(cj2))+((sj2)*(sj2)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst3;
gconst3=IKsign(((IkReal(8.78080000000000))+(((IkReal(15.6800000000000))*(cj2)))+(((IkReal(7.00000000000000))*((sj2)*(sj2))))+(((IkReal(7.00000000000000))*((cj2)*(cj2))))));
dummyeval[0]=((IkReal(1.25440000000000))+(((IkReal(2.24000000000000))*(cj2)))+((cj2)*(cj2))+((sj2)*(sj2)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x101=(px)*(px);
IkReal x102=(py)*(py);
IkReal x103=((IkReal(200.000000000000))*(sj2));
IkReal x104=((IkReal(56.0000000000000))*(sj2));
IkReal x105=((px)*(sj0));
IkReal x106=((cj0)*(py));
IkReal x107=((IkReal(56.0000000000000))*(cj2));
IkReal x108=((IkReal(200.000000000000))*(cj2));
if( IKabs(((gconst3)*(((((IkReal(-62.7200000000000))*(x105)))+(((IkReal(-1.00000000000000))*(x102)*(x103)))+(((x106)*(x107)))+(((IkReal(-1.00000000000000))*(x105)*(x107)))+(((IkReal(7.00000000000000))*(cj2)*(sj2)))+(((IkReal(10.9650000000000))*(sj2)))+(((IkReal(62.7200000000000))*(x106)))+(((IkReal(-1.00000000000000))*(x101)*(x103))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((gconst3)*(((IkReal(-12.2808000000000))+(((IkReal(-18.8050000000000))*(cj2)))+(((IkReal(224.000000000000))*(x102)))+(((IkReal(-1.00000000000000))*(x104)*(x105)))+(((x101)*(x108)))+(((x102)*(x108)))+(((IkReal(224.000000000000))*(x101)))+(((x104)*(x106)))+(((IkReal(-7.00000000000000))*((cj2)*(cj2)))))))) < IKFAST_ATAN2_MAGTHRESH )
    continue;
j1array[0]=IKatan2(((gconst3)*(((((IkReal(-62.7200000000000))*(x105)))+(((IkReal(-1.00000000000000))*(x102)*(x103)))+(((x106)*(x107)))+(((IkReal(-1.00000000000000))*(x105)*(x107)))+(((IkReal(7.00000000000000))*(cj2)*(sj2)))+(((IkReal(10.9650000000000))*(sj2)))+(((IkReal(62.7200000000000))*(x106)))+(((IkReal(-1.00000000000000))*(x101)*(x103)))))), ((gconst3)*(((IkReal(-12.2808000000000))+(((IkReal(-18.8050000000000))*(cj2)))+(((IkReal(224.000000000000))*(x102)))+(((IkReal(-1.00000000000000))*(x104)*(x105)))+(((x101)*(x108)))+(((x102)*(x108)))+(((IkReal(224.000000000000))*(x101)))+(((x104)*(x106)))+(((IkReal(-7.00000000000000))*((cj2)*(cj2))))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x109=IKsin(j1);
IkReal x110=IKcos(j1);
IkReal x111=((IkReal(1.00000000000000))*(py));
IkReal x112=((IkReal(0.125000000000000))*(sj2));
IkReal x113=((IkReal(0.140000000000000))*(sj0));
IkReal x114=((IkReal(0.125000000000000))*(cj2));
IkReal x115=((IkReal(0.0350000000000000))*(cj2));
IkReal x116=((IkReal(1.00000000000000))*(px));
IkReal x117=((sj0)*(x110));
IkReal x118=((cj0)*(x109));
IkReal x119=((IkReal(0.140000000000000))*(x110));
IkReal x120=((cj0)*(x110));
IkReal x121=((x109)*(x114));
evalcond[0]=((((IkReal(0.140000000000000))*(x109)))+(((x110)*(x112)))+(x121)+(((IkReal(-1.00000000000000))*(cj0)*(x111)))+(((px)*(sj0))));
evalcond[1]=((IkReal(0.140000000000000))+(((IkReal(-1.00000000000000))*(cj0)*(x116)))+(((IkReal(-1.00000000000000))*(x109)*(x112)))+(((x110)*(x114)))+(((IkReal(-1.00000000000000))*(sj0)*(x111)))+(x119));
evalcond[2]=((IkReal(0.0548250000000000))+(((IkReal(-1.00000000000000))*(py)*(x111)))+(((x110)*(x115)))+(((IkReal(0.0392000000000000))*(x110)))+(x115)+(((IkReal(-0.0350000000000000))*(sj2)*(x109)))+(((IkReal(-1.00000000000000))*(px)*(x116))));
evalcond[3]=((((IkReal(-1.00000000000000))*(sj0)*(x121)))+(((IkReal(-1.00000000000000))*(x112)*(x118)))+(((IkReal(-1.00000000000000))*(x112)*(x117)))+(((IkReal(-1.00000000000000))*(x116)))+(((IkReal(-1.00000000000000))*(x109)*(x113)))+(((x114)*(x120)))+(((cj0)*(x119)))+(((IkReal(0.140000000000000))*(cj0))));
evalcond[4]=((((x112)*(x120)))+(((x114)*(x118)))+(((x110)*(x113)))+(((IkReal(-1.00000000000000))*(x111)))+(((IkReal(0.140000000000000))*(x118)))+(x113)+(((IkReal(-1.00000000000000))*(sj0)*(x109)*(x112)))+(((x114)*(x117))));
if( IKabs(evalcond[0]) > 0.000001  || IKabs(evalcond[1]) > 0.000001  || IKabs(evalcond[2]) > 0.000001  || IKabs(evalcond[3]) > 0.000001  || IKabs(evalcond[4]) > 0.000001  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x122=((IkReal(8.96000000000000))*(py));
IkReal x123=((cj0)*(px));
IkReal x124=((IkReal(8.00000000000000))*(cj2));
IkReal x125=((cj0)*(py));
IkReal x126=((py)*(sj0));
IkReal x127=((IkReal(8.00000000000000))*(sj2));
IkReal x128=((IkReal(8.00000000000000))*(px)*(sj0));
if( IKabs(((gconst2)*(((((IkReal(-1.00000000000000))*(px)*(sj0)*(x124)))+(((IkReal(-8.96000000000000))*(px)*(sj0)))+(((IkReal(-1.00000000000000))*(x126)*(x127)))+(((IkReal(-1.00000000000000))*(x123)*(x127)))+(((x124)*(x125)))+(((IkReal(1.12000000000000))*(sj2)))+(((cj0)*(x122))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((gconst2)*(((IkReal(-1.25440000000000))+(((sj0)*(x122)))+(((x125)*(x127)))+(((IkReal(8.96000000000000))*(x123)))+(((x124)*(x126)))+(((IkReal(-1.12000000000000))*(cj2)))+(((IkReal(-1.00000000000000))*(px)*(sj0)*(x127)))+(((x123)*(x124))))))) < IKFAST_ATAN2_MAGTHRESH )
    continue;
j1array[0]=IKatan2(((gconst2)*(((((IkReal(-1.00000000000000))*(px)*(sj0)*(x124)))+(((IkReal(-8.96000000000000))*(px)*(sj0)))+(((IkReal(-1.00000000000000))*(x126)*(x127)))+(((IkReal(-1.00000000000000))*(x123)*(x127)))+(((x124)*(x125)))+(((IkReal(1.12000000000000))*(sj2)))+(((cj0)*(x122)))))), ((gconst2)*(((IkReal(-1.25440000000000))+(((sj0)*(x122)))+(((x125)*(x127)))+(((IkReal(8.96000000000000))*(x123)))+(((x124)*(x126)))+(((IkReal(-1.12000000000000))*(cj2)))+(((IkReal(-1.00000000000000))*(px)*(sj0)*(x127)))+(((x123)*(x124)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x129=IKsin(j1);
IkReal x130=IKcos(j1);
IkReal x131=((IkReal(1.00000000000000))*(py));
IkReal x132=((IkReal(0.125000000000000))*(sj2));
IkReal x133=((IkReal(0.140000000000000))*(sj0));
IkReal x134=((IkReal(0.125000000000000))*(cj2));
IkReal x135=((IkReal(0.0350000000000000))*(cj2));
IkReal x136=((IkReal(1.00000000000000))*(px));
IkReal x137=((sj0)*(x130));
IkReal x138=((cj0)*(x129));
IkReal x139=((IkReal(0.140000000000000))*(x130));
IkReal x140=((cj0)*(x130));
IkReal x141=((x129)*(x134));
evalcond[0]=((((x130)*(x132)))+(((IkReal(-1.00000000000000))*(cj0)*(x131)))+(((IkReal(0.140000000000000))*(x129)))+(((px)*(sj0)))+(x141));
evalcond[1]=((IkReal(0.140000000000000))+(((IkReal(-1.00000000000000))*(x129)*(x132)))+(((x130)*(x134)))+(x139)+(((IkReal(-1.00000000000000))*(cj0)*(x136)))+(((IkReal(-1.00000000000000))*(sj0)*(x131))));
evalcond[2]=((IkReal(0.0548250000000000))+(((x130)*(x135)))+(((IkReal(0.0392000000000000))*(x130)))+(((IkReal(-1.00000000000000))*(px)*(x136)))+(((IkReal(-0.0350000000000000))*(sj2)*(x129)))+(((IkReal(-1.00000000000000))*(py)*(x131)))+(x135));
evalcond[3]=((((IkReal(-1.00000000000000))*(sj0)*(x141)))+(((IkReal(-1.00000000000000))*(x132)*(x138)))+(((IkReal(-1.00000000000000))*(x129)*(x133)))+(((IkReal(-1.00000000000000))*(x136)))+(((cj0)*(x139)))+(((x134)*(x140)))+(((IkReal(-1.00000000000000))*(x132)*(x137)))+(((IkReal(0.140000000000000))*(cj0))));
evalcond[4]=((((x130)*(x133)))+(((IkReal(-1.00000000000000))*(sj0)*(x129)*(x132)))+(((IkReal(-1.00000000000000))*(x131)))+(((x134)*(x138)))+(((IkReal(0.140000000000000))*(x138)))+(((x132)*(x140)))+(x133)+(((x134)*(x137))));
if( IKabs(evalcond[0]) > 0.000001  || IKabs(evalcond[1]) > 0.000001  || IKabs(evalcond[2]) > 0.000001  || IKabs(evalcond[3]) > 0.000001  || IKabs(evalcond[4]) > 0.000001  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "25106211e00d8b4ed1669bdd1c290e4d"; }

IKFAST_API const char* GetIkFastVersion() { return IKFAST_STRINGIZE(IKFAST_VERSION); }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
